# -*- coding: utf-8 -*-
"""Capstone.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19IETf8OGKK2ME6S19vk5JCfpgqsHtjiU
"""

from google.colab import files
uploaded = files.upload()

# List exactly what you just uploaded
print(list(uploaded.keys()))

filename = "Online Retail Capstone.csv"

import csv
from collections import Counter, defaultdict
from google.colab import files # Make sure files is imported if you use it elsewhere
import sys # Import sys for sys.exit

# 3.1 Point to your actual uploaded filename
filename = "Online Retail Capstone.csv"

# 3.2 Prepare data structures
unique_customers = set()
product_counter  = Counter()
invoice_items     = defaultdict(int)
invoice_totals    = defaultdict(float)

# 3.3 Read and process
with open(filename, newline='', encoding='utf-8') as f:
    reader = csv.DictReader(f)
    # Print the keys of the first row to check column names
    try:
        # Read the first row to check headers
        first_row = next(reader)
        print("Available keys in the CSV header:", first_row.keys())
        # Reset the file pointer to the beginning after reading the first row
        f.seek(0)
        # Re-initialize the reader since we read the first row
        reader = csv.DictReader(f)
    except StopIteration:
        print("The CSV file appears to be empty or has no header.")
        # If the file is empty, we can't process, so stop execution here
        sys.exit("Cannot process an empty file.") # Using sys.exit to stop execution
    except Exception as e:
         print(f"An error occurred while reading the header: {e}")
         sys.exit(f"Failed to read CSV header due to error: {e}") # Using sys.exit


    # Check if essential columns exist BEFORE looping through rows
    required_keys = ['CustomerID', 'Quantity', 'UnitPrice']
    # Create a set of available keys, stripping whitespace for comparison
    available_keys_stripped = {key.strip() for key in first_row.keys()}

    # Check if all required keys (after stripping) are in the available keys (after stripping)
    if not all(key.strip() in available_keys_stripped for key in required_keys):
        print(f"Error: Missing one or more required columns in the CSV header.")
        print(f"Required keys: {required_keys}")
        print(f"Available keys (raw): {list(first_row.keys())}")
        print(f"Available keys (stripped): {list(available_keys_stripped)}")
        sys.exit("Missing required columns.") # Using sys.exit

    for row in reader:
        # Use .get() to safely access keys, providing a default value if the key is missing.
        # This is safer than direct row['key'] access if the file format is inconsistent
        # or has unexpected missing columns in later rows (though DictReader often handles this).
        # The check before the loop already ensures essential columns are in the header.
        # Use the stripped version of keys when accessing data if necessary, or ideally
        # DictReader handles this if you use the exact key from first_row.keys().
        # Let's stick to the raw keys from first_row.keys() for accessing row data
        # and rely on the header check confirming their presence after stripping.
        customer_id_raw = row.get('CustomerID', '') # 'CustomerID' did not have spaces
        product_raw     = row.get('Description', '') # 'Description' did not have spaces
        invoice_raw     = row.get('InvoiceNo', '') # 'InvoiceNo' did not have spaces
        quantity_raw     = row.get('Quantity', '0') # 'Quantity' did not have spaces
        # Access using the key with spaces, as DictReader uses the header exactly
        unit_price_raw  = row.get(' UnitPrice ', '0.0') # ' UnitPrice ' has spaces

        # Basic data cleaning and type conversion
        try:
            # Strip whitespace from string fields
            customer_id = customer_id_raw.strip()
            product      = product_raw.strip()
            invoice      = invoice_raw.strip()

            # Convert numeric fields. Using float() then int() for quantity handles potential decimals.
            quantity    = int(float(quantity_raw))
            unit_price  = float(unit_price_raw)

            # Calculate total amount for the row (Quantity * UnitPrice)
            total_amt = quantity * unit_price

        except ValueError:
            # If conversion to int or float fails, print a warning and skip the row
            # This handles non-numeric data in 'Quantity' or 'UnitPrice' columns
            print(f"Warning: Skipping row due to invalid numeric data in Quantity or UnitPrice: {row}")
            continue
        except Exception as e:
            # Catch any other unexpected errors during processing a single row
            print(f"Warning: Skipping row due to unexpected error during processing: {e} in row: {row}")
            continue

        # After cleaning and conversion, check for essential data validity
        # For example, skip if customer_id is empty after stripping or if quantity is non-positive
        if not customer_id or quantity <= 0 or unit_price <= 0:
             # print(f"Warning: Skipping row due to missing essential data or non-positive quantity/price: {row}")
             continue # Skip rows that don't meet basic criteria

        # If the row passed all checks, process it
        unique_customers.add(customer_id)
        product_counter[product] += 1
        invoice_items[invoice]   += quantity
        invoice_totals[invoice]  += total_amt

# 3.4 Compute your answers
# 1. Unique customers
print("\n1. Unique customers:", len(unique_customers))

# 2. Top 5 products
print("\n2. Top 5 most frequently ordered products:")
# Iterate through the most common products from the counter
for prod, cnt in product_counter.most_common(5):
    # Ensure the product description is not empty before printing
    if prod:
        print(f"   {prod}: {cnt} orders")
    else:
        # Handle cases where the top product might have an empty description
        print(f"   [Empty Description]: {cnt} orders")


# 3. Invoices with >10 items
print("\n3. Invoices with more than 10 items (invoice: total_amount):")
# Iterate through invoice items. Using list() creates a snapshot in case the dictionary changes
# during iteration (though not expected in this script after processing loop).
for inv, items in list(invoice_items.items()):
    if items > 10:
        # Access the corresponding total amount for this invoice
        # Use .get() with a default of 0.0 in case an invoice is somehow in invoice_items
        # but not in invoice_totals (which shouldn't happen with this logic, but good practice).
        total = invoice_totals.get(inv, 0.0)
        print(f"   {inv}: ${total:.2f}")

print("\nProcessing complete.")

# 1. Unique customers
print("\n1. Unique customers:", len(unique_customers))

# 2. Top 5 products
print("\n2. Top 5 most frequently ordered products:")
# Iterate through the most common products from the counter
for prod, cnt in product_counter.most_common(5):
    # Ensure the product description is not empty before printing
    if prod:
        print(f"   {prod}: {cnt} orders")
    else:
        # Handle cases where the top product might have an empty description
        print(f"   [Empty Description]: {cnt} orders")

# 3. Invoices with >10 items
print("\n3. Invoices with more than 10 items (invoice: total_amount):")
# Iterate through invoice items. Using list() creates a snapshot in case the dictionary changes
# during iteration (though not expected in this script after processing loop).
for inv, items in list(invoice_items.items()):
    if items > 10:
        # Access the corresponding total amount for this invoice
        # Use .get() with a default of 0.0 in case an invoice is somehow in invoice_items
        # but not in invoice_totals (which shouldn't happen with this logic, but good practice).
        total = invoice_totals.get(inv, 0.0)
        print(f"   {inv}: ${total:.2f}")